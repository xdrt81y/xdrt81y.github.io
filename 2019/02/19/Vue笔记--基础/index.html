<!DOCTYPE HTML>
<html lang="">
<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="Hexo">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->





<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->


<title>Vue 基础 | Hexo</title>


    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>




    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?2fc3a3d527c70b63cb22ac694eb6549b";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    
</head>


<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://7xpw2b.com1.z0.glb.clouddn.com/hexo-sinppet/img/banner.jpg)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='John Doe'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 王者风范 自由洒脱 </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://yoursite.com">Hexo</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>Home</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/IOS/"><i class="fa "></i>IOS</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/前端/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/后端/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/投资/"><i class="fa "></i>投资</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/读书/"><i class="fa "></i>读书</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/关于/"><i class="fa "></i>关于</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>时间轴</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Vue 基础">
            
	            Vue 基础
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/前端">
            前端
        </a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
                    <a href="/tags/vue" title='vue'>
                        vue
                    </a>
                
                    <a href="/tags/基础" title='基础'>
                        基础
                    </a>
                
                    <a href="/tags/语法" title='语法'>
                        语法
                    </a>
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2019/02/19</span>
        </span>
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>渐进式框架，核心库只关注视图层</p>
<h4 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a>声明式渲染</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var app = new Vue(&#123;</span><br><span class="line">    el:&apos;#app&apos;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        message : &apos;Hello Vue!&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>数据和DOM绑定在一起，即所有元素都是响应式的<br><strong>指令</strong>：带有前缀v-，以表示他们是Vue提供的特殊属性  </p>
<h4 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-3&quot;&gt;</span><br><span class="line">    &lt;p v-if=&quot;seen&quot;&gt;你看到了&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var app3 = new Vue(&#123;</span><br><span class="line">    el: &apos;#app-3&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        seen: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这意味着不仅可以绑定DOM到数据，也可以绑定DOM结构到数据。而且Vue在插入/更新/删除元素时自动采用<strong>过渡效果</strong><br>还有比如v-for指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-4&quot;&gt;</span><br><span class="line">    &lt;ol&gt;</span><br><span class="line">        &lt;li v-for=&quot;todo in todo&quot;&gt;</span><br><span class="line">            &#123;&#123;todo.text&#125;&#125;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">    &lt;/ol&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var app4 = new Vue(&#123;</span><br><span class="line">    el:&quot;#app-4&quot;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        todos: [</span><br><span class="line">            &#123;text: &quot;撒旦法地方&quot;&#125;，</span><br><span class="line">            &#123;text：&quot;对方是发达&quot;&#125;,</span><br><span class="line">            &#123;text: &quot;的方式&quot;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="处理用户输入"><a href="#处理用户输入" class="headerlink" title="处理用户输入"></a>处理用户输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-5&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;reverseMessage&quot;&gt;逆转消息&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var app5=new Vue(&#123;</span><br><span class="line">    el:&apos;#app-5&apos;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        message: &quot;Hello Vue.js!&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        reverseMessage:function()&#123;</span><br><span class="line">            this.message = this.message.split(&apos;&apos;).reverse().join(&apos;&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>能看得出，所有DOM操作都由Vue来处理，我们并没有触碰DOM<br>Vue还提供了v-model指令，他能轻松实现表单输入和应用状态之间的双向绑定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-6&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;input v-model=&quot;message&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var app6 = new Vue(&#123;</span><br><span class="line">    el: &apos;#app-6&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: &apos;Hello Vue!&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="组件化应用构建"><a href="#组件化应用构建" class="headerlink" title="组件化应用构建"></a>组件化应用构建</h3><p>它是一种抽象，类似积木一般来搭建大型应用<br>在Vue中，一个组件本质上是一个拥有预定义选项的一个Vue实例，在Vue中注册组件很简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//定义名为todo-item的新组件</span><br><span class="line">Vue.component(&apos;todo-item&apos;,&#123;</span><br><span class="line">    template: &apos;&lt;li&gt;这个是组件&lt;/li&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>现在构件组建模版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;!--创建一个todo-item组件的实例--&gt;</span><br><span class="line">    &lt;todo-item&gt;&lt;/todo-item&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>
<p>来扩展下，将数据从父作用域传到子组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;todo-item&apos;,&#123;</span><br><span class="line">    //todo-item组件现在接受一个“prop”</span><br><span class="line">    //类似于一个自定义属性</span><br><span class="line">    //这个属性名为todo</span><br><span class="line">    props:[&apos;todo&apos;],</span><br><span class="line">    template:&apos;&lt;li&gt;&#123;&#123;todo.text&#125;&#125;&lt;/li&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>然后，使用v-bind指令将todo传到每个重复的组件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-7&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">            现在为每个todo-item提供todo对象</span><br><span class="line">            todo对象是变量，即其内容是动态的</span><br><span class="line">            同时需要为每个组件提供一个‘key’</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;todo-item</span><br><span class="line">          v-for=&apos;item in groceryList&apos;</span><br><span class="line">          v-bind:todo=&apos;item&apos;</span><br><span class="line">          v-bind:key=&apos;item.id&apos;&gt;</span><br><span class="line">        &lt;/todo-item&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.component(&apos;todo-item&apos;,&#123;</span><br><span class="line">    props:[&apos;todo&apos;],</span><br><span class="line">    template:&apos;&lt;li&gt;&#123;&#123;todo.text&#125;&#125;&lt;/li&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var app7 = new Vue(&#123;</span><br><span class="line">    el:&apos;#app-7&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        groceryList:[</span><br><span class="line">            &#123;id:0,text:&apos;蔬菜&apos;&#125;,</span><br><span class="line">            &#123;id:1,text:&apos;奶酪&apos;&#125;,</span><br><span class="line">            &#123;id:2,text:&apos;辣酱&apos;&#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>子单元通过props接口实现了与父单元很好的解耦  </p>
<h4 id="与自定义元素的关系"><a href="#与自定义元素的关系" class="headerlink" title="#与自定义元素的关系"></a>#与自定义元素的关系</h4><p>能注意到，Vue组件非常类似于<strong>自定义元素</strong>————它是<strong>Web组件规范</strong>的一部分，因为Vue的组件语法部分参考了该规范，如Vue组件实现了Slot API与is特性，但还是有几个关键差别</p>
<ol>
<li>Web组件规范仍处草案阶段，尚无浏览器原生实现，而Vue组件不需任何补丁，且所有支持Vue的浏览器下表现一致，必要时，Vue组件也可以包装于原生自定义元素之内</li>
<li>Vue组件提供了纯自定义元素所不具备的一些重要功能，最突出的是跨组件数据流，自定义事件通信以及构建工具集成</li>
</ol>
<h2 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h2><p>虽然没有完全遵循<strong>MVVM模型</strong>，但无疑受到了它的启发<br>创建时可以传入一个选项对象，一个Vue应用由一个通过new Vue创建的根Vue实例，以及可选的嵌套的、可复用的组件树组成</p>
<h3 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h3><p>实例在创建时，会向Vue的响应式系统中加入其data对象中的所有属性。当这些属性值发生改变时，视图层就会发生<strong>响应</strong>，即匹配更新为新的值。当数据层改变时视图层会对应进行重渲染。<br><strong>不过要注意，只有当实例被创建的那一个data中存在的属性是响应的，之后在data中添加任何新属性都无法触发视图层更新</strong>，所以如果想再晚些时候需要辣么一个属性，记得设置初始值。<br>除了data属性，Vue还暴露了一些实例的属性和方法，他们都有前缀$,如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm.$data===data</span><br><span class="line">vm.$el===document.getElementById(&quot;app-7&quot;)</span><br></pre></td></tr></table></figure></p>
<h3 id="实例生命周期"><a href="#实例生命周期" class="headerlink" title="实例生命周期"></a>实例生命周期</h3><p>每个实例被创建时都会有一系列的初始化过程，例如需要设置数据监听、编译模版、挂载实例DOM、在数据变化时更新DOM等。<br><strong>同时该过程也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码</strong><br>如：create钩子就是用来在一个实例创建之后执行的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    data:&#123;</span><br><span class="line">        a:1</span><br><span class="line">    &#125;,</span><br><span class="line">    created:function()&#123;</span><br><span class="line">        //this 指向vm实例</span><br><span class="line">        console.log(this.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// -&gt; 1</span><br></pre></td></tr></table></figure></p>
<p>不过还有些钩子，在实例生命周期的不同场景下调用，如mounted、updated、destroyed。<br><strong>钩子的this指向调用他的Vue实例</strong></p>
<blockquote>
<p>不要在选项属性或回调上使用<strong>箭头函数</strong>，比如<br>created:() =&gt; console.log(this.a)或<br>vm.$watch(‘a’,newVlaue =&gt; this.myMethod())<br>因为箭头函数是和父级上下文绑定在一起的，<strong>this</strong>不会是你所预期的Vue实例，经常导致一些错误。<br>在此写下来，以便看到时知道那里犯了错</p>
<ol>
<li>Uncaught TypeError: Cannot read property of undefined</li>
<li>Uncaught TypeError: this.myMethod is not a function</li>
</ol>
</blockquote>
<h3 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h3><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="image"></p>
<h2 id="模版语法"><a href="#模版语法" class="headerlink" title="模版语法"></a>模版语法</h2><p>Vue.js使用基于HTML的模版语法，允许声明式地将DOM绑定至底层Vue实例的数据。所有模版都是合法html，所以能被浏览器和HTML解析器解析<br>底层实现上，Vue将模版编译成虚拟DOM渲染函数，结合响应系统，在应用状态改变时，Vue能智能地算出重渲染组建最小的代价并应用到DOM操作上<br>如果熟悉虚拟DOM并偏爱JS的原始力量，可以不用模版，<strong>直接写渲染（render）函数</strong>，使用可选的JSX语法  </p>
<h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><p>大括号语法不能作用在HTML特性上，请用v-bind指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id=&quot;newId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>这同样适用于布尔类特性，如果求值结果是falsy（<strong>指的是所有能被转换成false的值，包括false</strong>）的值，则该特性将会被删除<br>大括号里面可以写JS代码，但只能包含单个表达式，如三元表达式，而流控制是不会生效的  </p>
<blockquote>
<p>模版表达式只能访问全局变量的一个白名单，如Math和Date，不应该在模版表达式中试图访问用户定义的全局变量  </p>
</blockquote>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>带有v-前缀的特殊属性。<br>指令属性的值预期是<strong>单个JS表达式（v-for例外）</strong><br>指令的职责是，当表达式的值改变，将其连带影响响应式地作用于DOM</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="#参数"></a>#参数</h4><p>一个指令能接受一个参数，在指令名称后用“：”表示，如v-bind指令可用于响应式地更新HTML属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<p><em>href</em> 是参数，告知v-bind指令将该元素的href属性与表达式url的值绑定<br>再比如v-on指令，它用于监听DOM事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-on:click=&quot;dosomething&quot;&gt;...&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<p>这时，指令的参数是监听的事件名  </p>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="#修饰符"></a>#修饰符</h4><p>以半角句号“.”指明的特殊后缀，用于指出一个指令应该以特殊方式绑定<br>例如，.prevent修饰符告诉v-on指令对于出发的事件调用event.preventDefault():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="计算属性和观察者"><a href="#计算属性和观察者" class="headerlink" title="计算属性和观察者"></a>计算属性和观察者</h2><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>对于任何复杂逻辑，都应当使用<strong>计算属性</strong><br>来颗栗子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">    &lt;p&gt;Original message:&#123;&#123;message&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Computed reversed message:&#123;&#123;reversedMessage&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el:&apos;#example&apos;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        message: &apos;Hello&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line">        //计算属性的getter</span><br><span class="line">        reversedMessage:function()&#123;</span><br><span class="line">            //this 指向vm实例</span><br><span class="line">            return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>上栗声明了个计算属性reversedMessage，我们提供的函数将用作属性vm.reversedMessage的getter函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(vm.reversedMessage) //&apos;olleH&apos;</span><br><span class="line">vm.message=&apos;Goodbye&apos;</span><br><span class="line">console.log(vm.reversedMessage) //&apos;eybdooG&apos;</span><br></pre></td></tr></table></figure></p>
<p>Vue知道vm.reversedMessage依赖于vm.message，所以vm.message一旦变化，所有依赖vm.reversedMessage的绑定也会更新。而且最妙的是<strong>我们已经以声明的方式创建了这种依赖关系：计算属性的getter函数是没有副作用的，这是他更易于测试和理解</strong></p>
<h4 id="计算属性缓存vs方法"><a href="#计算属性缓存vs方法" class="headerlink" title="#计算属性缓存vs方法"></a>#计算属性缓存vs方法</h4><p>其实上例也可以通过在表达式中调用方法来达到同样的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Reversed message:&#123;&#123;reversedMessage()&#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">//在组件中</span><br><span class="line">methods:&#123;</span><br><span class="line">    reversedMessage:function()&#123;</span><br><span class="line">        return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种在method中定义方法，其最终结果确实和计算属性一样。蓝鹅，不同的是<strong>计算属性是基于他们的依赖进行缓存的</strong>。计算属性只有在与它的相关依赖发生改变时才会重新求值。<strong>这意味着只要message没变，怎么访问这个计算属性都不会再算一遍，会立即返回之前计算好的的结果</strong><br>而这导致了个有趣的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    now:function()&#123;</span><br><span class="line">        return Date.now()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>on属性将不再更新，因为Date.now()不是响应式依赖<br>相比之下，每当触发重新渲染时，调用方法将总会再次执行函数<br>为什么需要缓存?如果计算量花销很大，如果没有缓存会不可避免的多次执行计算  </p>
<h4 id="计算属性vs侦听属性"><a href="#计算属性vs侦听属性" class="headerlink" title="#计算属性vs侦听属性"></a>#计算属性vs侦听属性</h4><p>Vue提供了更通用的方式来观察和响应Vue实例上的数据变动：<strong>侦听属性</strong><br>当你有一些数据需要随着其他数据变动而变动时，会很容易滥用<em>watch</em> ————特别是有AngularJS经验的童鞋<br>而通常更好的方法是使用计算属性而不是命令式的watch回调</p>
<h4 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h4><p>当需要在数据变化时执行异步或开销较大的操作时，可以用watch来代替计算属性</p>
<h2 id="Class与Style绑定"><a href="#Class与Style绑定" class="headerlink" title="Class与Style绑定"></a>Class与Style绑定</h2><p>因为它们都是属性,所以可以用v-bind来处理:只需要通过表达式计算出字符串结果即可.<br>不过字符串拼接既麻烦且易错,因此在将v-bind用于class和style时,Vue.js做了专门的增强–表达式结果的类型除了是字符串外,还可以是对象或数组  </p>
<h3 id="绑定HTML-Class"><a href="#绑定HTML-Class" class="headerlink" title="绑定HTML Class"></a>绑定HTML Class</h3><h4 id="对象语法"><a href="#对象语法" class="headerlink" title="#对象语法"></a>#对象语法</h4><p>可以传给v-bind:class一个对象,用来动态切换class:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;&#123;active:isActive&#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>上面的语法表示active这个class取决于isActive这个属性是否为true.<br>可以在对象中传入更多属性,该指令也可以与普通的class属性并存,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;app-1&quot; v-bind:class=&quot;&#123;active:isActive,test:isTest&#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>三元表达式也可以用在这<br>数组也可以用在这  </p>
<h4 id="用在组件上"><a href="#用在组件上" class="headerlink" title="#用在组件上"></a>#用在组件上</h4><p>不会覆盖掉原有的class,比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;my-component&apos;,&#123;</span><br><span class="line">    template:&apos;&lt;p class=&quot;foo bar&quot;&gt;&lt;/p&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>然后在调用插件的时候添加一些class:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure></p>
<p>HTML将被渲染为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi&lt;/p&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h3><h4 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="#对象语法"></a>#对象语法</h4><p>v-bind:style的对象语法看着很像CSS,但其实是个JS对象.CSS属性名可以用驼峰或横短线分隔:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;&#123;width:activeWidth+&apos;px&apos;,color:activeColor&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data:&#123;</span><br><span class="line">    activeWidth:299,</span><br><span class="line">    activeColor:&apos;orange&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接绑个样式对象通常更好,会更清晰:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data:&#123;</span><br><span class="line">    styleObject:&#123;</span><br><span class="line">        color:&apos;red&apos;,</span><br><span class="line">        fontSize:&apos;12px&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>v-bind:style在添加需要前缀的CSS属性时会自己添上  </p>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><h4 id="在元素上使用v-if条件渲染分组"><a href="#在元素上使用v-if条件渲染分组" class="headerlink" title="#在元素上使用v-if条件渲染分组"></a>#在<template>元素上使用v-if条件渲染分组</template></h4><p><template>就是当作块儿用的,不会出现在渲染结果上</template></p>
<h4 id="v-else"><a href="#v-else" class="headerlink" title="#v-else"></a>#v-else</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;Math.random()&gt;0.5&quot;&gt;</span><br><span class="line">    Now you see me</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;</span><br><span class="line">    Now you don&apos;t</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>v-else元素必须紧跟在带v-if或v-else-if的后面</p>
<h4 id="v-else-if"><a href="#v-else-if" class="headerlink" title="#v-else-if"></a>#v-else-if</h4><p>2.1.0新增,顾名思义</p>
<h4 id="用key管理可复用的元素"><a href="#用key管理可复用的元素" class="headerlink" title="#用key管理可复用的元素"></a>#用key管理可复用的元素</h4><p>Vue会尽可能高效地渲染元素,通常会复用已有元素而不是从头渲染,例如input框中的文本,如果Vue觉得这个input不需要在渲染,那就留着.不过有些需要中这个不应该存在,这是就需要绑定一个key,让Vue知道这个input不是同一个,需要重新渲染</p>
<h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><p>带有v-show的元素始终会被渲染并保留在DOM中,其实就是切换display属性  </p>
<blockquote>
<p><strong>不过要注意v-show不支持<template>元素,也不支持v-else</template></strong></p>
</blockquote>
<h4 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a>v-if <em>vs</em> v-show</h4><p>v-if是真正的条件渲染,在切换过程中条件块中的事件监听器和自组件会被销毁和重建<br>v-if也是<strong>惰性</strong>的:如果初始条件为假则啥也不做,直到条件变成真才开始渲染<br>相比之下,v-show就简单得多,元素总是会被渲染<br>一般来说,v-if有更高的切换开销,而v-show有更高的初始渲染开销.<br>因此如果需要频繁切换,则使用v-show;<br>如果运行时条件很少改变,则使用v-if较好</p>
<h4 id="v-if-与-v-for一起使用"><a href="#v-if-与-v-for一起使用" class="headerlink" title="v-if 与 v-for一起使用"></a>v-if 与 v-for一起使用</h4><p>v-for具有比v-if更高的优先级</p>
<h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><p>在v-for中,我们拥有对父作用域属性的完全访问权限.v-for还支持一个可选的第二个参数作为当前项的索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;example-2&quot;&gt;</span><br><span class="line">    &lt;li v-for=&quot;(item,index) in items&quot;&gt;</span><br><span class="line">        &#123;&#123;parentMessage&#125;&#125;-&#123;&#123;index&#125;&#125;-&#123;&#123;item.message&#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var example2 = nwe Vue(&#123;</span><br><span class="line">    el:&quot;#example-2&quot;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        parentMessage:&apos;Parent&apos;,</span><br><span class="line">        items:[</span><br><span class="line">        &#123;message:&apos;Foo&apos;&#125;,</span><br><span class="line">        &#123;message:&apos;Bar&apos;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>结果:<br>Parent-0-Foo<br>Parent-1-Bar<br>也可以用of替代in作为分隔符,毕竟这是最接近JS迭代器的语法  </p>
<h4 id="一个对象的v-for"><a href="#一个对象的v-for" class="headerlink" title="一个对象的v-for"></a>一个对象的v-for</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;v-for-object&quot; class=&quot;demo&quot;&gt;</span><br><span class="line">    &lt;li v-for=&quot;(key,value,index) in object&quot;&gt;</span><br><span class="line">    &#123;&#123;key&#125;&#125;-&#123;&#123;value&#125;&#125;-&#123;&#123;index&#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el:&quot;#v-for-object&quot;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        object:&#123;</span><br><span class="line">            firstName: &apos;John&apos;,</span><br><span class="line">            lastName: &apos;Doe&apos;,</span><br><span class="line">            age: 30</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在遍历对象时,是按Obejct.keys()的结果遍历,不能保证结果在不同的JS引擎下是一致的</p>
<h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p>由于就地复用策略,如果数据项的顺序被改变,Vue却不会迁就去改变DOM元素的顺序,而是简单复用此处每个元素,且确保它在特定索引下显示已被渲染过的每个元素<br>该默认模式是高效的,但只适用于<strong>不依赖子组件状态或临时DOM状态的列表渲染输出</strong><br>为了给个提示,以便Vue能跟踪每个节点的身份,从而重用和重排现有元素,需要提供唯一性的key属性<br>尽量在使用v-for时提供key,除非遍历输出的DOM内容非常简单<br>因为它是Vue识别节点的一个通用机制,key并不与v-for特别关联,key还具有其他用途</p>
<h3 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h3><h4 id="变异方法"><a href="#变异方法" class="headerlink" title="#变异方法"></a>#变异方法</h4><p>Vue有观察数组的变异方法,例如push() pop()等方法,都会触发视图层的更新  </p>
<h4 id="替换数组"><a href="#替换数组" class="headerlink" title="#替换数组"></a>#替换数组</h4><p>变异方法(mutation method)顾名思义,会改变被这些方法调用的原始数组.相比之下,也有非变异方法,如filter(),concat(),slice().这些不会改变原始数组,但总是返回一个新数组.当使用非变异方法时,可以用新数组替换旧数组来达到触发视图层改变</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="#注意事项"></a>#注意事项</h4><p>由于JS的限制,Vue不能检测以下变动的数组:  </p>
<ol>
<li>当利用索引直接设置一个项时,比如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2. 当修改数组的长度时，比如```vm.items.length = newLength```  </span><br><span class="line">  </span><br><span class="line">第一类问题,有两个方法可以解决:  </span><br><span class="line">比如设置vm.items[indexOfItem]=newValue时</span><br></pre></td></tr></table></figure></li>
</ol>
<p>Vue.set(example1.items,indexOfItem,newValue)<br>//<br>example1.items.splice(indexOfItem,1,newValue)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第二类问题,可以用splice:</span><br></pre></td></tr></table></figure></p>
<p>example1.items.splice(newLength)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 对象更改检测注意事项</span><br><span class="line">由于JS限制,Vue不能检测对象属性的添加或删除</span><br><span class="line">这个之前就提过,实例创建时data所有属性会被设置为响应式的,再之后就不会识别  </span><br><span class="line">当然还是有办法解决的,可以使用Vue.set(object,key,value)的方法向嵌套对象添加响应式属性</span><br><span class="line"></span><br><span class="line">### 一段取值范围的v-for</span><br><span class="line">v-for可以取整数,如&quot;n in 10&quot;,将重复多次模版.如日历表格生成时可用这个  </span><br><span class="line"></span><br><span class="line">### v-for on a &lt;template&gt;</span><br><span class="line">类似于v-if v-for也支持它</span><br><span class="line"></span><br><span class="line">### v-for with v-if  </span><br><span class="line">当处于同一节点,v-for优先级更高,这意味着v-if将分别重复运行与每个v-for循环中.</span><br></pre></td></tr></table></figure></p>
<p><li v-for="todo in todos" v-if="!todo.isComplete"></li><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上述代码只传递了为complete的todo  </span><br><span class="line">如果目的在于有条件地跳过循环的执行,可以将v-if至于外层元素或&lt;template&gt;上,如:</span><br></pre></td></tr></table></figure></p>
<p><ul v-if="todos.length"><br>    <li v-for="todo in todos"><br>        <br>    </li><br></ul></p>
<p></p><p v-else="">No todos left!</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 一个组件的v-for</span><br><span class="line">在自定义组件中,可以像普通元素一样用v-for  </span><br><span class="line">然而任何数据都不会自动传递到组件里,因为组件有自己独立的作用域.为了把迭代数据传递到组件里,要用props:</span><br></pre></td></tr></table></figure><p></p>
<p><my-component v-for="(item,index) in items" v-bind:item="item" v-bind:index="index" v-bind:key="item.id"><br></my-component><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">至于不自动将item注入到组件里的原因是,这会使得组件与v=for的运作紧密耦合.而明确组件数据的来源能够使组件在其他场合重复使用  </span><br><span class="line">下面是一个简单的todo list的完成例子:</span><br></pre></td></tr></table></figure></p>
<div id="todo=list-example"><br>    <input v-model="newTodoText" v-on:keyup.enter="addNewTodo" placeholer="Add a todo"><br>    <ul><br>        <li is="todo-item" v-for="(todo,index) in todos" v-bind:key="todo.id" v-bind:title="todo.title" v-on:remove="todos.splice(index,1)"><br>        </li><br>    </ul><br></div><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;注意这里的is=&quot;todo-item&quot;属性,这种做法在使用DOM模版时是十分必要的,因为在ul元素内只有li元素会被看作有效内容,这样做实现的效果与&lt;todo-item&gt;相同,但是可以避开一些潜在的浏览器解析错误</span><br></pre></td></tr></table></figure><br><br>Vue.component(‘todo-item’,{<br>    template:’\<br>    <li>\<br>      Vue 基础\<br>      <button v-on:click="$emit(\'remove\')">X</button>\<br>    </li>\’,<br>    props:[‘title’]<br>})<br><br>new Vue({<br>    el:’#toto-list-example’,<br>    data:{<br>        newTodoText:’’,<br>        todos:[<br>            {<br>                id: 1,<br>                title: ‘Do the dishes’,<br>            },<br>            {<br>                id: 2,<br>                title: ‘Take out the trash’,<br>            },<br>            {<br>                id: 3,<br>                title: ‘Mow the lawn’<br>            }<br>        ],<br>        nextTodoId:4<br>    },<br>    methods:{<br>        addNewTodo:function(){<br>            this.todos.push({<br>                id:this.nextTodoId++,<br>                title:this.newTodoText<br>            })<br>            this.newTodoText=’’<br>        }<br>    }<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 事件处理</span><br><span class="line"></span><br><span class="line">用v-on指令监听DOM事件来触发JS代码</span><br><span class="line"></span><br><span class="line">### 事件修饰符</span><br><span class="line">事件处理中阻止冒泡或阻止默认是很常见的需求.尽管methods中可以很容易实现,但更好的方式是:methods只负责纯粹的数据逻辑,而不是去处理DOM事件细节  </span><br><span class="line">为此Vue为v-on提供了**事件修饰符**  </span><br><span class="line">- .stop  </span><br><span class="line">- .prevent</span><br><span class="line">- .capture</span><br><span class="line">- .self</span><br><span class="line">- .once</span><br></pre></td></tr></table></figure><br><br><!--阻止单击事件冒泡--><br><a v-on:click.stop="doThis"></a><br><!--提交事件不再重载页面--><br><form v-on:submit.prevent="onSubmit"></form><br><!--修饰符时可以串联的,如stop和prevent可共用,但要注意顺序--><br><a v-on:click.stop.prevent="doThis"></a><br><!--只有修饰符也是允许的--><br><form v-on:submit.prevent=""></form><br><!--添加事件侦听器时使用事件捕获模式--><br><div v-on:click.capture="doThis"><div><br><!--只有事件在该元素本身触发时触发回调--><br><div v-on:click.self="doThat"></div><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;使用修饰符时,顺序很重要;相应的代码会以相应顺序产生.因此如@click.prevent.self会阻止所有的点击,而@click.self.prevent只会阻止元素上的点击  </span><br><span class="line"></span><br><span class="line">2.1.4新增了.once修饰符,表示事件将只会触发一次</span><br></pre></td></tr></table></figure><br><br><a v-on:click.once="doThis"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">不像其它只能对原生DOM事件起作用的修饰符,.once修饰符可以用在自定义的组件事件上  </span><br><span class="line">#### #鼠标按钮修饰符</span><br><span class="line">2.1.0新增  </span><br><span class="line">- .left</span><br><span class="line">- .right</span><br><span class="line">- .middle</span><br><span class="line"></span><br><span class="line">用以监听特定的滑鼠按键  </span><br><span class="line"></span><br><span class="line">### 为什么在HTML中监听事件?</span><br><span class="line">这并非违背了关注点分离的传统理念,因为所有的Vue.js事件处理方法和表达式都严格绑定在当前视图的ViewModel上,他不会导致任何维护上的困难  </span><br><span class="line">使用v-on的好处:  </span><br><span class="line">- 和DOM完全解耦,更易调试</span><br><span class="line">- 当一个VM被销毁时,所有事件处理器都会自动被删除,因此无需担心如何手动清理它们  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 表单输入绑定</span><br><span class="line"></span><br><span class="line">### 基础用法</span><br><span class="line">v-model本质上不过是语法糖,负责监听用户的输入事件以更新数据</span><br><span class="line"></span><br><span class="line">#### #复选框</span><br></pre></td></tr></table></figure><br><br><div id="example-3"><br>    <input type="checkbox" id="jack" v-model="checkedNames"><br>    <label for="jack"></label><br>    <input type="checkbox" id="Bob" v-model="chedkedNames"><br>    <label for="Bob"></label><br>    <input type="checkbox" id="John" v-model="checkedNames"><br>    <label for="John"></label><br>    <br><br>    <span>Checked names:</span><br></div>


<p>new Vue({<br>    el:”#example-3”,<br>    data:{<br>        checkedNames:[]<br>    }<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### #选择列表</span><br><span class="line">单选列表:</span><br></pre></td></tr></table></figure></p>
<div id="example-4"><br>    <select v-model="selsected"><br>        <option disabled value="">请选择</option><br>        <option>A</option><br>        <option>B</option><br>        <option>C</option><br>    </select><br>    <span>Selected:</span><br></div>


<p>new Vue({<br>    el:’…’,<br>    data:{<br>        selsected:’’<br>    }<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;之所以写这个,是有个注意项:如果v-model表达初始的值不匹配任何选项,&lt;select&gt;就会以&quot;未选中&quot;的状态渲染.  </span><br><span class="line">在iOS中,这会使用户无法选择第一个选项,因为这样的情况下,iOS不会引发change事件.因为要提供disabled选项</span><br><span class="line"></span><br><span class="line">### 修饰符</span><br><span class="line">#### #.lazy</span><br><span class="line">默认情况下,v-model在input事件中同步输入框的值与数据.而如果添加lazy,就转变为在change事件中同步</span><br><span class="line">#### #.number</span><br><span class="line">如果项将输入值转为Number类型,这个很有用</span><br></pre></td></tr></table></figure></p>
<p><input v-model.number="age" type="number"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### #.trim</span><br><span class="line">过滤输入的首尾空格</span><br></pre></td></tr></table></figure></p>
<p><input v-model.trim="msg"><br><code>`</code></p>
</div></div>
    </div>

    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="http://xdrt81y.github.io" target="_blank">xdrt81y</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2019/02/20/Vuex/" class="pre-post btn btn-default" title='Vuex'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">Vuex</span>
        </a>
    
    
        <a href="/2019/02/12/《股市进阶之道》读书笔记/" class="next-post btn btn-default" title='《股市进阶之道》读书笔记'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">《股市进阶之道》读书笔记</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
    
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: 'qVeSssBVuyUsf6nmVTlxfhR3-gzGzoHsz',
            appKey: 'zqe88AIrGzAIw41jK7K0zbqk',
            placeholder: '说点什么吧',
            notify: false,
            verify: false,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: ''.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">Table of Contents</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#介绍"><span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#声明式渲染"><span class="toc-text">声明式渲染</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#条件与循环"><span class="toc-text">条件与循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理用户输入"><span class="toc-text">处理用户输入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组件化应用构建"><span class="toc-text">组件化应用构建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#与自定义元素的关系"><span class="toc-text">#与自定义元素的关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue实例"><span class="toc-text">Vue实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据与方法"><span class="toc-text">数据与方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例生命周期"><span class="toc-text">实例生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生命周期图示"><span class="toc-text">生命周期图示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模版语法"><span class="toc-text">模版语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#插值"><span class="toc-text">插值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指令"><span class="toc-text">指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#参数"><span class="toc-text">#参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修饰符"><span class="toc-text">#修饰符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计算属性和观察者"><span class="toc-text">计算属性和观察者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#计算属性"><span class="toc-text">计算属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#计算属性缓存vs方法"><span class="toc-text">#计算属性缓存vs方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#计算属性vs侦听属性"><span class="toc-text">#计算属性vs侦听属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#侦听器"><span class="toc-text">侦听器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class与Style绑定"><span class="toc-text">Class与Style绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#绑定HTML-Class"><span class="toc-text">绑定HTML Class</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#对象语法"><span class="toc-text">#对象语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用在组件上"><span class="toc-text">#用在组件上</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绑定内联样式"><span class="toc-text">绑定内联样式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#对象语法-1"><span class="toc-text">#对象语法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条件渲染"><span class="toc-text">条件渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#在元素上使用v-if条件渲染分组"><span class="toc-text">#在元素上使用v-if条件渲染分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-else"><span class="toc-text">#v-else</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-else-if"><span class="toc-text">#v-else-if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用key管理可复用的元素"><span class="toc-text">#用key管理可复用的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-show"><span class="toc-text">v-show</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-if-vs-v-show"><span class="toc-text">v-if vs v-show</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-if-与-v-for一起使用"><span class="toc-text">v-if 与 v-for一起使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#列表渲染"><span class="toc-text">列表渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一个对象的v-for"><span class="toc-text">一个对象的v-for</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#key"><span class="toc-text">key</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组更新检测"><span class="toc-text">数组更新检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#变异方法"><span class="toc-text">#变异方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#替换数组"><span class="toc-text">#替换数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注意事项"><span class="toc-text">#注意事项</span></a></li></ol></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12"> 
                <span>Copyright &copy; 2017
                </span> | 
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> | 
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>



<script src="/js/app.js?rev=@@hash"></script>


</body>
</html>